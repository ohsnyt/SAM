//
//  SAMStoreSeed.swift
//  SAM_crm
//
//  One-time bootstrap, guarded by `sam.swiftdata.seeded`.  Runs once
//  at app launch; after that flag is set it is a permanent no-op.
//
//  On a fresh install `FixtureSeeder` runs first and populates People,
//  Contexts, and Evidence with stable UUIDs.  This file's only live
//  job is Pass 3: resolving any `proposedLink.targetID`s that don't
//  yet point at the correct SwiftData objects.  Passes 1 and 2 simply
//  snapshot whatever is already in the store into name-keyed maps for
//  Pass 3 to use.
//

import SwiftData
import Foundation

// ─────────────────────────────────────────────────────────────────────
// MARK: - Entry point
// ─────────────────────────────────────────────────────────────────────

enum SAMStoreSeed {

    /// The single flag that prevents re-seeding after the first run.
    private static let seededKey = "sam.swiftdata.seeded"

    /// Call this once at app launch (e.g. from the `App` body or a
    /// `.task` on the root view).  It is a no-op if the store has
    /// already been seeded.
    @MainActor
    static func seedIfNeeded(into context: ModelContext) {
        guard !UserDefaults.standard.bool(forKey: seededKey) else { return }

        // ── Pass 1: Contexts ──────────────────────────────────────
        let contexts = seedContexts(into: context)

        // ── Pass 2: People ────────────────────────────────────────
        let people = seedPeople(into: context, contexts: contexts)

        // ── Pass 3: Evidence (resolves proposedLink targetIDs) ───
        seedEvidence(into: context, people: people, contexts: contexts)

        // ── Commit ────────────────────────────────────────────────
        do {
            try context.save()
            UserDefaults.standard.set(true, forKey: seededKey)
        } catch {
            // If save fails the flag stays false — we'll retry next launch.
            // In production you'd want to surface this, but for now just log.
            NSLog("SAMStoreSeed: save failed — %@", error.localizedDescription)
        }
    }
}

// ─────────────────────────────────────────────────────────────────────
// MARK: - Pass 1 — Contexts
// ─────────────────────────────────────────────────────────────────────
//
// Snapshots existing SamContext rows into a name → model map.
// If the store is completely empty a minimal default context is
// created so the app has something to render on first launch.
// ─────────────────────────────────────────────────────────────────────

extension SAMStoreSeed {

    /// Returns a name → SamContext lookup so later passes can wire
    /// relationships by name.
    private static func seedContexts(into context: ModelContext) -> [String: SamContext] {
        var map: [String: SamContext] = [:]

        // Populate from any existing contexts already in the store.
        if let existing: [SamContext] = try? context.fetch(FetchDescriptor<SamContext>()) {
            for c in existing {
                map[c.name] = c
            }
        }

        // If there are no contexts yet, create a minimal default context for testing/training.
        if map.isEmpty {
            let defaultContextID = UUID(uuidString: "11111111-1111-1111-1111-111111111111") ?? UUID()
            let defaultContext = SamContext(
                id:                 defaultContextID,
                name:               "Sample Household",
                kind:               .household,
                consentAlertCount:  0,
                reviewAlertCount:   0,
                followUpAlertCount: 0
            )

            // Minimal embedded product card to exercise UI
            defaultContext.productCards = [
                ContextProductModel(
                    id: UUID(uuidString: "22222222-2222-2222-2222-222222222222") ?? UUID(),
                    title: "Life Insurance",
                    subtitle: "Term Policy",
                    statusDisplay: "Active",
                    icon: "heart.fill"
                )
            ]

            // Minimal interaction chip
            defaultContext.recentInteractions = [
                InteractionModel(
                    id: UUID(uuidString: "33333333-3333-3333-3333-333333333333") ?? UUID(),
                    title: "Intro Call",
                    subtitle: "Discussed needs",
                    whenText: "Last week",
                    icon: "phone.fill"
                )
            ]

            // Minimal insight (no evidence linked in seed; will be generated by InsightGenerator)
            defaultContext.insights = [
                SamInsight(
                    kind: .followUp,
                    message: "Follow up to review coverage options.",
                    confidence: 0.5
                )
            ]

            // Create a relational Product matching the product card
            let product = Product(
                id: UUID(uuidString: "44444444-4444-4444-4444-444444444444") ?? UUID(),
                type: .lifeInsurance,
                name: "Life Insurance",
                statusDisplay: "Active",
                icon: "heart.fill",
                subtitle: "Term Policy",
                context: defaultContext
            )
            context.insert(product)

            context.insert(defaultContext)
            map[defaultContext.name] = defaultContext
        }

        return map
    }
}

// ─────────────────────────────────────────────────────────────────────
// MARK: - Pass 2 — People
// ─────────────────────────────────────────────────────────────────────
//
// Snapshots existing SamPerson rows into a displayName → model map.
// People arrive here via FixtureSeeder or ContactsImportCoordinator;
// this pass does not insert any new rows.
// ─────────────────────────────────────────────────────────────────────

extension SAMStoreSeed {

    /// Returns a displayName → SamPerson lookup.
    private static func seedPeople(
        into context: ModelContext,
        contexts: [String: SamContext]
    ) -> [String: SamPerson] {
        var map: [String: SamPerson] = [:]

        if let existingPeople: [SamPerson] = try? context.fetch(FetchDescriptor<SamPerson>()) {
            for p in existingPeople {
                if !p.displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    map[p.displayName] = p
                }
            }
        }

        return map
    }
}

// ─────────────────────────────────────────────────────────────────────
// MARK: - Pass 3 — Evidence
// ─────────────────────────────────────────────────────────────────────
//
// Resolves proposedLink.targetIDs on every SamEvidenceItem in the
// store.  On a fresh install FixtureSeeder already uses the correct
// stable UUIDs (SeedIDs), so this is a no-op in practice.  It remains
// as a safety net for any install where evidence was seeded before the
// matching People/Contexts were present.
// ─────────────────────────────────────────────────────────────────────

extension SAMStoreSeed {

    private static func seedEvidence(
        into context: ModelContext,
        people:   [String: SamPerson],
        contexts: [String: SamContext]
    ) {
        let existing: [SamEvidenceItem] = (try? context.fetch(FetchDescriptor<SamEvidenceItem>())) ?? []

        for item in existing {
            item.proposedLinks = item.proposedLinks.map { link -> ProposedLink in
                let resolvedID: UUID
                switch link.target {
                case .person:
                    resolvedID = people[link.displayName]?.id ?? link.targetID
                case .context:
                    resolvedID = contexts[link.displayName]?.id ?? link.targetID
                }
                return ProposedLink(
                    id:            link.id,
                    target:        link.target,
                    targetID:      resolvedID,
                    displayName:   link.displayName,
                    secondaryLine: link.secondaryLine,
                    confidence:    link.confidence,
                    reason:        link.reason,
                    status:        link.status,
                    decidedAt:     link.decidedAt
                )
            }
        }
    }
}







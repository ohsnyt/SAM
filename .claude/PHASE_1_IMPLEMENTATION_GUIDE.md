# Phase 1 Implementation Guide: Persist Person/Context Insights

**Goal:** Replace embedded `PersonInsight` and `ContextInsight` value types with a persisted `SamInsight` `@Model` class and `@Relationship` to `SamPerson` and `SamContext`.

**Estimated time:** 4-6 hours  
**Risk level:** Low (isolated to detail views)  
**Prerequisite:** Read `INSIGHT_PROMOTION_PLAN.md` and `INSIGHT_PROMOTION_SUMMARY.md`

---

## Step 1: Add `SamInsight` @Model Class

**File:** `SAMModels.swift`  
**Location:** After the `SamEvidenceItem` class definition, before the end of file

```swift
// ─────────────────────────────────────────────────────────────────────
// MARK: - 10. Insights (promoted from embedded value types)
// ─────────────────────────────────────────────────────────────────────

/// A persisted AI recommendation or observation attached to a person,
/// context, or product.
///
/// Insights are generated by signal analysis (InsightGeneratorV1) and
/// serve both the detail views (Person/Context) and the Awareness
/// dashboard.
///
/// **Phase 1:** Basic @Model with entity relationships and lifecycle.
/// **Phase 2:** Awareness will query these instead of computing runtime insights.
/// **Phase 3:** `evidenceIDs` will become `@Relationship var basedOnEvidence: [SamEvidenceItem]`.
@Model
final class SamInsight {
    @Attribute(.unique) var id: UUID

    // ── Relationships (entity this insight is about) ───────────────
    var samPerson:  SamPerson?
    var samContext: SamContext?
    var product:    Product?

    // ── Core properties ─────────────────────────────────────────────
    var kind:       InsightKind
    var message:    String
    var confidence: Double

    // ── Supporting evidence (flat array for Phase 1) ───────────────
    /// Phase 3 will convert this to `@Relationship var basedOnEvidence: [SamEvidenceItem]`.
    /// For now, we store UUIDs to preserve the explainability data structure.
    var evidenceIDs: [UUID] = []

    // ── Lifecycle ───────────────────────────────────────────────────
    var createdAt:   Date
    var dismissedAt: Date?

    // ── Display helpers (computed from supporting evidence) ─────────
    /// Count of interactions referenced by this insight.
    /// For now, this is set manually when creating the insight.
    /// Phase 3 will compute from actual `basedOnInteractions` relationship.
    var interactionsCount: Int = 0

    /// Count of consent requirements referenced by this insight.
    /// Phase 3 will add `@Relationship var basedOnConsents: [ConsentRequirement]`.
    var consentsCount: Int = 0

    init(
        id: UUID = UUID(),
        samPerson: SamPerson?  = nil,
        samContext: SamContext? = nil,
        product: Product?      = nil,
        kind: InsightKind,
        message: String,
        confidence: Double,
        evidenceIDs: [UUID]    = [],
        interactionsCount: Int = 0,
        consentsCount: Int     = 0
    ) {
        self.id                = id
        self.samPerson         = samPerson
        self.samContext        = samContext
        self.product           = product
        self.kind              = kind
        self.message           = message
        self.confidence        = confidence
        self.evidenceIDs       = evidenceIDs
        self.interactionsCount = interactionsCount
        self.consentsCount     = consentsCount
        self.createdAt         = .now
    }
}
```

**Verify:**
- [ ] Class is marked `@Model` and `final`
- [ ] `id` has `@Attribute(.unique)`
- [ ] All optional relationships are properly typed (`SamPerson?`, not `SamPerson`)
- [ ] `createdAt` defaults to `.now`

---

## Step 2: Add Relationships to `SamPerson` and `SamContext`

**File:** `SAMModels.swift`

### In `SamPerson` class:

**Find this section (near the end of the class, after `contextChips`):**

```swift
var contextChips: [ContextChip] = []
```

**Add below it:**

```swift
// ── Insights (promoted from embedded value type) ───────────────
@Relationship(deleteRule: .cascade)
var insights: [SamInsight] = []
```

**Then delete the old embedded array** (search for `var insights: [PersonInsight]`):

```swift
// DELETE THIS LINE:
// var insights: [PersonInsight] = []
```

### In `SamContext` class:

**Find this section (near the end of the class, after `recentInteractions`):**

```swift
var recentInteractions: [InteractionModel] = []
```

**Add below it:**

```swift
// ── Insights (promoted from embedded value type) ───────────────
@Relationship(deleteRule: .cascade)
var insights: [SamInsight] = []
```

**Then delete the old embedded array** (search for `var insights: [ContextInsight]`):

```swift
// DELETE THIS LINE:
// var insights: [ContextInsight] = []
```

**Verify:**
- [ ] Both relationships use `.cascade` delete rule (insight deleted when person/context deleted)
- [ ] Old `[PersonInsight]` and `[ContextInsight]` arrays are removed
- [ ] No compiler errors (embedded structs still exist in `SAMModelEnums.swift`)

---

## Step 3: Update Schema in App Entry Point

**File:** `SAM_crmApp.swift`

**Find the schema definition:**

```swift
let schema = Schema([
    SamPerson.self,
    SamContext.self,
    SamEvidenceItem.self,
    // ... other models
])
```

**Add `SamInsight.self` to the array:**

```swift
let schema = Schema([
    SamPerson.self,
    SamContext.self,
    SamEvidenceItem.self,
    SamInsight.self,  // ← ADD THIS
    ContextParticipation.self,
    Responsibility.self,
    JointInterest.self,
    ConsentRequirement.self,
    Product.self,
    Coverage.self
])
```

**Verify:**
- [ ] Build succeeds (⌘B)
- [ ] No schema validation errors in console

---

## Step 4: Make `SamInsight` Conform to `InsightDisplayable`

**File:** `SAMModelEnums.swift` (or `InsightCardView.swift` if you prefer)

**Find this section (near the end of the file, after `extension ContextInsight`):**

```swift
extension PersonInsight:  InsightDisplayable {}
extension ContextInsight: InsightDisplayable {}
```

**Add below it:**

```swift
extension SamInsight: InsightDisplayable {
    // SamInsight already has all required properties:
    // - kind: InsightKind
    // - message: String
    // - confidence: Double
    // - interactionsCount: Int
    // - consentsCount: Int
}
```

**Verify:**
- [ ] `InsightCardView<SamInsight>` compiles without error
- [ ] `InsightDisplayable` protocol doesn't require any additional properties

---

## Step 5: Update Fixture Seeder

**File:** `FixtureSeeder.swift`

**Find the section where people are created** (look for `let alice = SamPerson(...)`).

**Find where insights are assigned** (search for `.insights =`). You'll see something like:

```swift
alice.insights = [
    PersonInsight(
        kind: .followUp,
        message: "...",
        confidence: 0.72,
        interactionsCount: 3,
        consentsCount: 0
    )
]
```

**Replace with:**

```swift
// Create insights as separate @Model instances
let aliceInsight = SamInsight(
    samPerson: alice,
    kind: .followUp,
    message: "Consider scheduling annual review.",
    confidence: 0.72,
    interactionsCount: 3,
    consentsCount: 0
)
context.insert(aliceInsight)

// No need to set alice.insights — the relationship is automatic
```

**Do the same for:**
- Bob's insights
- Any context insights (e.g., smithFamily.insights)

**Example for context insight:**

```swift
let householdInsight = SamInsight(
    samContext: smithFamily,
    kind: .consentMissing,
    message: "Spousal consent may need review.",
    confidence: 0.88,
    interactionsCount: 1,
    consentsCount: 2
)
context.insert(householdInsight)
```

**Verify:**
- [ ] All `PersonInsight(...)` replaced with `SamInsight(samPerson: ...)`
- [ ] All `ContextInsight(...)` replaced with `SamInsight(samContext: ...)`
- [ ] Each insight has `context.insert()` call
- [ ] No direct assignment to `.insights` array (relationship is bidirectional)

---

## Step 6: Update Person Detail Host

**File:** `PersonDetailHost.swift`

**Find this line** (in the computed `personDetail` property):

```swift
let insights: [PersonInsight] = person.insights
```

**Change to:**

```swift
let insights: [SamInsight] = person.insights
```

**Verify:**
- [ ] Type matches the new relationship
- [ ] No other changes needed (PersonDetailModel will be updated in Step 8)

---

## Step 7: Update Context Detail Router

**File:** `ContextDetailRouter.swift` (or wherever `SamContext.insights` is read)

**Find where context insights are mapped to the detail model:**

```swift
let insights = context.insights  // was [ContextInsight]
```

**Verify type is now:**

```swift
let insights = context.insights  // now [SamInsight]
```

**If there's explicit type annotation, update it:**

```swift
let insights: [SamInsight] = context.insights
```

**Verify:**
- [ ] Build succeeds
- [ ] ContextDetailModel accepts the new type (next step)

---

## Step 8: Update Detail View Models

### Option A: Use Concrete Type (Recommended for Phase 1)

**File:** `PersonDetailModel.swift`

**Change:**
```swift
let insights: [PersonInsight]
```

**To:**
```swift
let insights: [SamInsight]
```

**File:** `ContextDetailModel.swift`

**Change:**
```swift
let insights: [ContextInsight]
```

**To:**
```swift
let insights: [SamInsight]
```

### Option B: Use Protocol Type (More flexible)

If you want to keep the model generic:

```swift
let insights: [any InsightDisplayable]
```

This allows mixing `SamInsight`, `PersonInsight`, and `ContextInsight` during migration.

**Verify:**
- [ ] `PersonDetailView` and `ContextDetailView` still compile
- [ ] `InsightCardView<SamInsight>` works (it's generic over `InsightDisplayable`)

---

## Step 9: Update Backup Payload

**File:** `BackupPayload.swift`

### 9.1 Add DTO

**Add after `BackupEvidenceItem` struct:**

```swift
struct BackupInsight: Codable, Identifiable {
    let id: UUID
    let personID:  UUID?
    let contextID: UUID?
    let productID: UUID?
    let kind:      String
    let message:   String
    let confidence: Double
    let evidenceIDs: [UUID]
    let interactionsCount: Int
    let consentsCount: Int
    let createdAt:   Date
    let dismissedAt: Date?
}
```

### 9.2 Add Property to `BackupPayload`

**In the main `BackupPayload` struct, add:**

```swift
let insights: [BackupInsight]
```

### 9.3 Update `current(using:)` Method

**Find the section where evidence is fetched:**

```swift
let evidence = try context.fetch(FetchDescriptor<SamEvidenceItem>())
```

**Add below it:**

```swift
// Fetch insights
let insights = try context.fetch(FetchDescriptor<SamInsight>()).map { insight in
    BackupInsight(
        id: insight.id,
        personID: insight.samPerson?.id,
        contextID: insight.samContext?.id,
        productID: insight.product?.id,
        kind: insight.kind.rawValue,
        message: insight.message,
        confidence: insight.confidence,
        evidenceIDs: insight.evidenceIDs,
        interactionsCount: insight.interactionsCount,
        consentsCount: insight.consentsCount,
        createdAt: insight.createdAt,
        dismissedAt: insight.dismissedAt
    )
}
```

**Update the `BackupPayload` return statement:**

```swift
return BackupPayload(
    version: Self.currentVersion,
    createdAt: Date(),
    people: people,
    contexts: contexts,
    evidence: evidence,
    insights: insights  // ← ADD THIS
)
```

### 9.4 Update `restore(into:)` Method

**Find where people and contexts are restored:**

```swift
// Restore people
var personByID: [UUID: SamPerson] = [:]
for dto in people {
    let person = SamPerson(...)
    context.insert(person)
    personByID[dto.id] = person
}

// Restore contexts
var contextByID: [UUID: SamContext] = [:]
for dto in contexts {
    let ctx = SamContext(...)
    context.insert(ctx)
    contextByID[dto.id] = ctx
}
```

**Add after the context restoration (before evidence):**

```swift
// Restore insights
for dto in insights {
    let insight = SamInsight(
        id: dto.id,
        kind: InsightKind(rawValue: dto.kind) ?? .followUp,
        message: dto.message,
        confidence: dto.confidence,
        evidenceIDs: dto.evidenceIDs,
        interactionsCount: dto.interactionsCount,
        consentsCount: dto.consentsCount
    )
    insight.createdAt = dto.createdAt
    insight.dismissedAt = dto.dismissedAt
    
    // Link to entities
    if let personID = dto.personID {
        insight.samPerson = personByID[personID]
    }
    if let contextID = dto.contextID {
        insight.samContext = contextByID[contextID]
    }
    if let productID = dto.productID {
        // Product restore not yet implemented; skip for now
        // insight.product = productByID[productID]
    }
    
    context.insert(insight)
}
```

**Verify:**
- [ ] `BackupInsight` DTO is `Codable`
- [ ] Insights are restored **after** people and contexts (to resolve relationships)
- [ ] Insights are restored **before** evidence (in case evidence references insights in Phase 3)

---

## Step 10: Build and Test

### 10.1 Clean Build

```bash
⌘⇧K  # Clean build folder
⌘B   # Build
```

**Expected:** No compiler errors

### 10.2 Run App with Fresh Database

1. Delete the app's container to start fresh:
   - In Xcode: Product → Scheme → Edit Scheme → Run → Options
   - Check "Reset AppData on Launch" (or manually delete `~/Library/Containers/SAM_crm/`)

2. Launch app (⌘R)

3. **Verify fixture seeding:**
   - Open People tab
   - Select a person
   - Scroll to "Insights" section
   - **Expected:** Insights appear (e.g., "Consider scheduling annual review")

4. **Verify persistence:**
   - Note which insights are showing
   - Quit app (⌘Q)
   - Relaunch app
   - **Expected:** Same insights are still there

### 10.3 Test Context Detail

1. Open Contexts tab
2. Select a context (e.g., "Smith Family")
3. Scroll to Insights section
4. **Expected:** Context insights appear (e.g., "Spousal consent may need review")

### 10.4 Test Backup/Restore

1. Go to Settings → Backup
2. Create a backup (no password for testing)
3. Note the file location
4. Quit app
5. Delete app container (reset database)
6. Launch app
7. Go to Settings → Backup
8. Restore from the backup file
9. Navigate to People → select person
10. **Expected:** Insights are restored correctly

---

## Step 11: Verify Phase 1 Complete

### Checklist

- [ ] `SamInsight` @Model exists in `SAMModels.swift`
- [ ] `SamPerson.insights` is `@Relationship [SamInsight]`
- [ ] `SamContext.insights` is `@Relationship [SamInsight]`
- [ ] Schema includes `SamInsight.self`
- [ ] `SamInsight` conforms to `InsightDisplayable`
- [ ] FixtureSeeder creates `SamInsight` instances
- [ ] PersonDetailHost uses `[SamInsight]`
- [ ] ContextDetailRouter uses `[SamInsight]`
- [ ] PersonDetailModel uses `[SamInsight]`
- [ ] ContextDetailModel uses `[SamInsight]`
- [ ] BackupPayload includes `BackupInsight` DTO
- [ ] Backup current() serializes insights
- [ ] Backup restore() deserializes insights
- [ ] Build succeeds with no errors
- [ ] App launches successfully
- [ ] Insights appear in Person detail
- [ ] Insights appear in Context detail
- [ ] Insights persist after app restart
- [ ] Backup/restore preserves insights

---

## Common Issues & Fixes

### Issue: "Type 'SamInsight' does not conform to protocol 'InsightDisplayable'"

**Fix:** Add extension in `SAMModelEnums.swift`:

```swift
extension SamInsight: InsightDisplayable {}
```

Verify `SamInsight` has all required properties: `kind`, `message`, `confidence`, `interactionsCount`, `consentsCount`.

---

### Issue: Fixtures don't show insights after first run

**Cause:** `FixtureSeeder` is idempotent (guarded by UserDefaults flag).

**Fix:** Delete app container to reset:
- Product → Scheme → Edit Scheme → Run → Options → Reset AppData
- Or manually delete: `~/Library/Containers/com.yourorg.SAM_crm/`

---

### Issue: Backup restore fails with "Key not found" error

**Cause:** Old backup files don't have `insights` array.

**Fix:** Make `insights` optional during decoding:

```swift
// In BackupPayload init(from decoder:):
self.insights = try container.decodeIfPresent([BackupInsight].self, forKey: .insights) ?? []
```

---

### Issue: Relationships are nil after restore

**Cause:** Insights restored before people/contexts.

**Fix:** Ensure restore order is:
1. People
2. Contexts
3. Products
4. **Insights** ← must come after entities
5. Evidence
6. Participations, etc.

---

## Next Steps: Phase 2 Preparation

Once Phase 1 is complete and stable:

1. **Read Phase 2 plan** in `INSIGHT_PROMOTION_PLAN.md`
2. **Design insight generation pipeline:**
   - When to run? (background job after evidence import)
   - What triggers regeneration? (new evidence, evidence linked to person/context)
   - How to avoid duplicates? (check existing insights before creating)
3. **Prototype `InsightGenerator` actor:**
   - Start with a simple version that converts one `EvidenceSignal` → one `SamInsight`
   - Test in isolation before wiring into Awareness
4. **Update Awareness to query `SamInsight`:**
   - Replace `EvidenceBackedInsight` computation with `@Query<SamInsight>`
   - Add navigation from Awareness to Person/Context detail

---

## Rollback Plan

If Phase 1 causes issues:

1. **Revert schema change:**
   - Remove `SamInsight.self` from schema
   - Add back `var insights: [PersonInsight]` to `SamPerson`
   - Add back `var insights: [ContextInsight]` to `SamContext`

2. **Revert FixtureSeeder:**
   - Replace `SamInsight(...)` with `PersonInsight(...)` and direct array assignment

3. **Revert BackupPayload:**
   - Remove `insights: [BackupInsight]` property
   - Remove insight serialization/deserialization

4. **Clean build and test**

The rollback is safe because Phase 1 doesn't touch Awareness (it still computes `EvidenceBackedInsight` independently).

---

## Success Criteria

✅ Phase 1 is complete when:

1. Person detail view shows persisted insights
2. Context detail view shows persisted insights
3. Insights survive app restarts
4. Backup/restore preserves insights with correct relationships
5. No regression in existing views (Awareness, Inbox, Evidence)
6. No performance degradation
7. All tests pass (if you have unit tests)

**Once verified, commit Phase 1 and move to Phase 2.**


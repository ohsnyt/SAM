# Insight Promotion to First-Class @Model — Implementation Plan

**Status:** Preparation Phase  
**Date:** February 5, 2026  
**Goal:** Convert embedded `PersonInsight` and `ContextInsight` value types into a unified, persisted `SamInsight` `@Model` class that serves both Person/Context detail views and the Awareness screen.

---

## Current State Analysis

### Three Parallel Insight Systems

Today, SAM has **three separate insight representations**:

1. **`PersonInsight`** (embedded value type on `SamPerson.insights`)
   - `struct PersonInsight: Identifiable, Codable, Hashable`
   - Properties: `kind`, `message`, `confidence`, `interactionsCount`, `consentsCount`
   - Stored as an embedded array on `SamPerson`
   - Not persisted across app launches
   - No evidence linkage

2. **`ContextInsight`** (embedded value type on `SamContext.insights`)
   - `struct ContextInsight: Identifiable, Codable, Hashable`
   - Identical shape to `PersonInsight`
   - Stored as an embedded array on `SamContext`
   - Same limitations: not persisted, no evidence linkage

3. **`EvidenceBackedInsight`** (runtime-only, used by `AwarenessHost`)
   - `struct EvidenceBackedInsight: InsightDisplayable, Hashable`
   - Properties: `kind`, `typeDisplayName`, `message`, `confidence`, `interactionsCount`, `consentsCount`, `evidenceIDs`
   - Computed fresh on every view render from `SamEvidenceItem.signals`
   - **Critical:** Carries `evidenceIDs: [UUID]` for drill-through to supporting evidence
   - **Problem:** Has no `samContact` or `context` reference, so there's nothing to navigate to from Awareness

### Design Doc Vision (§10, §13)

The design doc (`data-model.md §10`) describes a **unified `Insight` @Model**:

```swift
@Model
final class Insight {
    @Attribute(.unique) var id: UUID

    var samContact: SamContact?
    var context: Context?
    var product: Product?

    var type: InsightType
    var message: String
    var confidence: Double

    var basedOnInteractions: [Interaction]
    var basedOnConsents: [ConsentRequirement]

    var createdAt: Date
    var dismissedAt: Date?
}
```

**Key points:**
- Insights can be attached to a person, context, or product (optionally more than one)
- They explicitly reference supporting evidence (`basedOnInteractions`, `basedOnConsents`)
- They track lifecycle state (`createdAt`, `dismissedAt`)
- They persist across launches

---

## Scope Resolution Required

### Critical Question: Unified vs. Separate Models?

**The design doc calls for a single `Insight` model shared by Person/Context detail views and Awareness.**

However, the current implementation shows a **semantic split**:

#### Person/Context Insights (Today)
- Attached to a specific entity
- Displayed in detail views
- "What does this person/context need?"
- No evidence drill-through in current UI

#### Awareness Insights (`EvidenceBackedInsight`)
- Derived from **evidence signals**, not attached to entities
- Grouped by signal bucket (compliance, relationshipRisk, followUp, opportunity)
- "What needs attention in my entire book of business?"
- Evidence drill-through is the primary interaction

**Before starting implementation, we must decide:**

1. **Unified approach:** One `SamInsight` model that serves both use cases
   - Pros: Matches design doc vision, single source of truth, simpler schema
   - Cons: Awareness needs to materialize insights for *every* piece of evidence, even if not attached to a person/context yet

2. **Hybrid approach:** Keep `EvidenceBackedInsight` as runtime-only, add `SamInsight` for Person/Context
   - Pros: Awareness stays lightweight (computed on demand), Person/Context insights persist
   - Cons: Two parallel systems, more complex

3. **Signal-based approach:** Promote `EvidenceSignal` to `@Model`, generate `SamInsight` only when evidence is linked
   - Pros: Awareness can still derive from signals, insights become "promoted signals"
   - Cons: Duplicates signal storage (embedded on evidence + separate model)

**Recommendation:** Start with **Unified approach (#1)** per design doc intent, but implement in phases:
- Phase 1: Persist Person/Context insights as `SamInsight`
- Phase 2: Migrate Awareness to query `SamInsight` instead of computing runtime insights
- Phase 3: Add evidence linkage and drill-through

---

## Implementation Phases

### Phase 1: Create `SamInsight` @Model and Migrate Person/Context Detail Views

**Goal:** Replace embedded `PersonInsight` / `ContextInsight` value types with persisted `SamInsight` relationships.

#### 1.1 Define the `@Model` class

Add to `SAMModels.swift`:

```swift
// ─────────────────────────────────────────────────────────────────────
// MARK: - 10. Insights (promoted from embedded value types)
// ─────────────────────────────────────────────────────────────────────

/// A persisted AI recommendation or observation attached to a person,
/// context, or product.
///
/// Insights are generated by signal analysis (InsightGeneratorV1) and
/// serve both the detail views (Person/Context) and the Awareness
/// dashboard.
@Model
final class SamInsight {
    @Attribute(.unique) var id: UUID

    // ── Relationships (entity this insight is about) ───────────────
    var samPerson:  SamPerson?
    var samContext: SamContext?
    var product:    Product?

    // ── Core properties ─────────────────────────────────────────────
    var kind:       InsightKind
    var message:    String
    var confidence: Double

    // ── Supporting evidence (will be relationships in Phase 3) ──────
    /// For now, store evidence IDs as a flat array.
    /// Phase 3 will convert this to `@Relationship` once we decide
    /// between `[SamEvidenceItem]` or a dedicated join model.
    var evidenceIDs: [UUID] = []

    // ── Lifecycle ───────────────────────────────────────────────────
    var createdAt:   Date
    var dismissedAt: Date?

    // ── Display helpers (computed from supporting evidence) ─────────
    /// Count of interactions referenced by this insight.
    /// For now, derived from `evidenceIDs.count`; Phase 3 will compute
    /// from actual `basedOnInteractions` relationship.
    var interactionsCount: Int = 0

    /// Count of consent requirements referenced by this insight.
    /// Phase 3 will add `@Relationship var basedOnConsents: [ConsentRequirement]`.
    var consentsCount: Int = 0

    init(
        id: UUID = UUID(),
        samPerson: SamPerson?  = nil,
        samContext: SamContext? = nil,
        product: Product?      = nil,
        kind: InsightKind,
        message: String,
        confidence: Double,
        evidenceIDs: [UUID]    = [],
        interactionsCount: Int = 0,
        consentsCount: Int     = 0
    ) {
        self.id                = id
        self.samPerson         = samPerson
        self.samContext        = samContext
        self.product           = product
        self.kind              = kind
        self.message           = message
        self.confidence        = confidence
        self.evidenceIDs       = evidenceIDs
        self.interactionsCount = interactionsCount
        self.consentsCount     = consentsCount
        self.createdAt         = .now
    }
}
```

#### 1.2 Add relationships to `SamPerson` and `SamContext`

In `SAMModels.swift`, update:

```swift
// Inside SamPerson:
@Relationship(deleteRule: .cascade)
var insights: [SamInsight] = []

// Inside SamContext:
@Relationship(deleteRule: .cascade)
var insights: [SamInsight] = []
```

**Remove the embedded arrays:**
```swift
// DELETE from SamPerson and SamContext:
// var insights: [PersonInsight] = []
// var insights: [ContextInsight] = []
```

#### 1.3 Update `ModelContainer` schema

In `SAM_crmApp.swift`, add `SamInsight` to the schema:

```swift
let schema = Schema([
    SamPerson.self,
    SamContext.self,
    SamEvidenceItem.self,
    SamInsight.self,  // ← ADD THIS
    ContextParticipation.self,
    Responsibility.self,
    JointInterest.self,
    ConsentRequirement.self,
    Product.self,
    Coverage.self
])
```

#### 1.4 Make `SamInsight` conform to `InsightDisplayable`

Add to `SAMModelEnums.swift` or `InsightCardView.swift`:

```swift
extension SamInsight: InsightDisplayable {
    // Already has all required properties: kind, message, confidence, interactionsCount, consentsCount
}
```

#### 1.5 Update Backup DTOs

Add to `BackupPayload.swift`:

```swift
struct BackupInsight: Codable, Identifiable {
    let id: UUID
    let personID:  UUID?
    let contextID: UUID?
    let productID: UUID?
    let kind:      String
    let message:   String
    let confidence: Double
    let evidenceIDs: [UUID]
    let interactionsCount: Int
    let consentsCount: Int
    let createdAt:   Date
    let dismissedAt: Date?
}

// In BackupPayload:
let insights: [BackupInsight]

// In current():
let insights = try context.fetch(FetchDescriptor<SamInsight>()).map { insight in
    BackupInsight(
        id: insight.id,
        personID: insight.samPerson?.id,
        contextID: insight.samContext?.id,
        productID: insight.product?.id,
        kind: insight.kind.rawValue,
        message: insight.message,
        confidence: insight.confidence,
        evidenceIDs: insight.evidenceIDs,
        interactionsCount: insight.interactionsCount,
        consentsCount: insight.consentsCount,
        createdAt: insight.createdAt,
        dismissedAt: insight.dismissedAt
    )
}

// In restore():
// After inserting all SamPerson, SamContext, Product:
for dto in insights {
    let insight = SamInsight(
        id: dto.id,
        kind: InsightKind(rawValue: dto.kind) ?? .followUp,
        message: dto.message,
        confidence: dto.confidence,
        evidenceIDs: dto.evidenceIDs,
        interactionsCount: dto.interactionsCount,
        consentsCount: dto.consentsCount
    )
    insight.createdAt = dto.createdAt
    insight.dismissedAt = dto.dismissedAt
    
    if let personID = dto.personID {
        insight.samPerson = personByID[personID]
    }
    if let contextID = dto.contextID {
        insight.samContext = contextByID[contextID]
    }
    if let productID = dto.productID {
        insight.product = productByID[productID]
    }
    
    context.insert(insight)
}
```

#### 1.6 Update `PersonDetailHost` and `ContextDetailRouter`

Change from:
```swift
let insights: [PersonInsight] = person.insights
```

To:
```swift
let insights: [SamInsight] = person.insights
```

Since `SamInsight` now conforms to `InsightDisplayable`, `InsightCardView<SamInsight>` will work without changes.

#### 1.7 Update `PersonDetailModel` and `ContextDetailModel`

Option A: Change type to `[SamInsight]`
```swift
struct PersonDetailModel {
    // ...
    let insights: [SamInsight]
}
```

Option B (less disruptive): Keep as protocol type
```swift
struct PersonDetailModel {
    // ...
    let insights: [any InsightDisplayable]
}
```

#### 1.8 Update `FixtureSeeder`

Replace mock `PersonInsight` / `ContextInsight` creation with `SamInsight` instances:

```swift
// In FixtureSeeder.seedIfNeeded():
let aliceInsight = SamInsight(
    id: UUID(),
    samPerson: alice,
    kind: .followUp,
    message: "Consider scheduling annual review.",
    confidence: 0.72,
    interactionsCount: 3,
    consentsCount: 0
)
context.insert(aliceInsight)

// No need to manipulate embedded arrays; relationship is automatic
```

---

### Phase 2: Migrate Awareness to Use `SamInsight`

**Goal:** Replace runtime `EvidenceBackedInsight` computation with queries against persisted `SamInsight` rows.

**Blockers:**
- Need an **insight generation pipeline** that creates `SamInsight` rows from `SamEvidenceItem.signals`
- Need to decide when insights are created: on evidence import? on demand? background job?

#### 2.1 Create `InsightGenerator` Service

```swift
/// Generates and persists SamInsight rows from evidence signals.
actor InsightGenerator {
    let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    /// Generate insights for all evidence items that have signals but no insights.
    func generatePendingInsights() async throws {
        let evidence = try modelContext.fetch(
            FetchDescriptor<SamEvidenceItem>(
                predicate: #Predicate { !$0.signals.isEmpty }
            )
        )
        
        for item in evidence {
            try await generateInsights(for: item)
        }
        
        try modelContext.save()
    }
    
    /// Generate insights for a specific evidence item.
    func generateInsights(for evidence: SamEvidenceItem) async throws {
        // Group signals by bucket (same logic as AwarenessHost)
        guard let bestSignal = evidence.signals.max(by: { $0.confidence < $1.confidence }) else {
            return
        }
        
        let bucket = bucketFor(signal: bestSignal)
        let message = bucket.message(target: nil) // TODO: resolve target name
        
        // Check if insight already exists for this evidence
        let existingInsights = try modelContext.fetch(
            FetchDescriptor<SamInsight>(
                predicate: #Predicate { $0.evidenceIDs.contains(evidence.id) }
            )
        )
        
        if existingInsights.isEmpty {
            let insight = SamInsight(
                id: UUID(),
                samPerson: evidence.linkedPeople.first,
                samContext: evidence.linkedContexts.first,
                kind: bucket.kind,
                message: message,
                confidence: bestSignal.confidence,
                evidenceIDs: [evidence.id],
                interactionsCount: 1,
                consentsCount: bucket.consentsCountHint
            )
            modelContext.insert(insight)
        }
    }
    
    // Copy bucket logic from AwarenessHost
    private func bucketFor(signal: EvidenceSignal) -> SignalBucket { /* ... */ }
}
```

#### 2.2 Update `AwarenessHost` to Query `SamInsight`

```swift
struct AwarenessHost: View {
    @Query(filter: #Predicate<SamInsight> { $0.dismissedAt == nil })
    private var insights: [SamInsight]
    
    var body: some View {
        AwarenessView(
            insights: sortedInsights,
            onInsightTapped: { insight in
                // Navigate to person/context if available
                if let person = insight.samPerson {
                    navigationModel.selectedPersonID = person.id
                } else if let context = insight.samContext {
                    navigationModel.selectedContextID = context.id
                } else {
                    // Fall back to evidence drill-in
                    whySheet = WhySheetItem(
                        title: insight.message,
                        evidenceIDs: insight.evidenceIDs
                    )
                }
            }
        )
    }
    
    private var sortedInsights: [SamInsight] {
        insights.sorted {
            let pa = priority(for: $0.kind)
            let pb = priority(for: $1.kind)
            if pa != pb { return pa < pb }
            return $0.confidence > $1.confidence
        }
    }
}
```

---

### Phase 3: Add Evidence Relationships

**Goal:** Replace `evidenceIDs: [UUID]` with proper `@Relationship` to `SamEvidenceItem`.

#### 3.1 Add Relationship to `SamInsight`

```swift
@Model
final class SamInsight {
    // ...
    
    // REPLACE:
    // var evidenceIDs: [UUID] = []
    
    // WITH:
    @Relationship(deleteRule: .nullify)
    var basedOnEvidence: [SamEvidenceItem] = []
}
```

#### 3.2 Add Inverse Relationship to `SamEvidenceItem`

```swift
@Model
final class SamEvidenceItem {
    // ...
    
    @Relationship(deleteRule: .nullify, inverse: \SamInsight.basedOnEvidence)
    var relatedInsights: [SamInsight] = []
}
```

#### 3.3 Update `InsightCardView` Evidence Section

```swift
private extension InsightCardView where I == SamInsight {
    var evidenceSection: some View {
        VStack(alignment: .leading, spacing: 6) {
            if hasEvidence {
                Text("Based on")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                
                ForEach(insight.basedOnEvidence) { evidence in
                    Button {
                        // Navigate to evidence detail
                    } label: {
                        EvidenceRow(
                            icon: evidence.source.systemImage,
                            label: evidence.title
                        )
                    }
                    .buttonStyle(.plain)
                }
            }
        }
    }
    
    var hasEvidence: Bool {
        !insight.basedOnEvidence.isEmpty
    }
}
```

---

## Migration Checklist

### Prerequisites
- [ ] Confirm unified model approach vs. hybrid approach (see "Scope Resolution" above)
- [ ] Review all current uses of `PersonInsight` and `ContextInsight` in codebase
- [ ] Confirm Awareness drill-through UX: navigate to entity or show evidence?

### Phase 1: Basic @Model
- [ ] Add `SamInsight` @Model to `SAMModels.swift`
- [ ] Add `@Relationship var insights: [SamInsight]` to `SamPerson` and `SamContext`
- [ ] Remove embedded `var insights: [PersonInsight/ContextInsight]` arrays
- [ ] Update `ModelContainer` schema in `SAM_crmApp.swift`
- [ ] Make `SamInsight` conform to `InsightDisplayable`
- [ ] Update `PersonDetailHost` and `ContextDetailRouter` to use `SamInsight`
- [ ] Update `PersonDetailModel` and `ContextDetailModel` insight types
- [ ] Update `FixtureSeeder` to create `SamInsight` instances
- [ ] Add `BackupInsight` DTO and update `BackupPayload` current/restore
- [ ] Test: Person detail and Context detail show insights correctly
- [ ] Test: Backup/restore preserves insights

### Phase 2: Awareness Migration
- [ ] Create `InsightGenerator` actor/service
- [ ] Decide when to run generation: app launch? background? on-demand?
- [ ] Implement signal → insight conversion (port `AwarenessHost` bucket logic)
- [ ] Update `AwarenessHost` to query `SamInsight` instead of computing runtime insights
- [ ] Add navigation from Awareness to Person/Context detail
- [ ] Test: Awareness shows correct insights after evidence import
- [ ] Test: Tapping insight in Awareness navigates to entity or evidence

### Phase 3: Evidence Relationships
- [ ] Add `@Relationship var basedOnEvidence: [SamEvidenceItem]` to `SamInsight`
- [ ] Add inverse relationship to `SamEvidenceItem`
- [ ] Remove `var evidenceIDs: [UUID]` from `SamInsight`
- [ ] Update `InsightCardView` to navigate to evidence
- [ ] Update `InsightGenerator` to link evidence
- [ ] Test: Evidence drill-through from insight cards
- [ ] Test: Deleting evidence nullifies insight relationships (doesn't delete insight)

---

## Open Questions

1. **When are insights generated?**
   - Option A: Synchronously during evidence import (blocks import)
   - Option B: Background job after import completes
   - Option C: On-demand when Awareness view appears
   - **Recommendation:** Option B (background job) to keep import fast

2. **How are insights updated when evidence changes?**
   - Option A: Regenerate all insights on every evidence change
   - Option B: Insights are immutable; create new ones and expire old ones
   - Option C: Update insight confidence/message when linked evidence changes
   - **Recommendation:** Option B (immutable) with `dismissedAt`/`expiredAt` lifecycle

3. **Should insights be shared across entities?**
   - Example: "Household structure change" insight attached to both spouses and the household context
   - Option A: One insight, multiple entity relationships (`samPerson` is an array)
   - Option B: Duplicate insights per entity
   - **Recommendation:** Option A (shared) to avoid duplication

4. **What triggers insight expiration?**
   - Evidence is linked to a person/context?
   - Evidence is marked "done"?
   - User dismisses insight?
   - **Recommendation:** User-driven dismissal only; expired insights stay in DB for audit

5. **Should `EvidenceBackedInsight` survive as a view-model?**
   - Could keep it as a computed wrapper around `SamInsight` for Awareness
   - **Recommendation:** No; use `SamInsight` directly with `InsightDisplayable`

---

## Files That Will Change

### Core Models
- `SAMModels.swift` — add `SamInsight`, update `SamPerson` and `SamContext` relationships
- `SAMModelEnums.swift` — extend `SamInsight` with `InsightDisplayable` conformance
- `SAM_crmApp.swift` — add `SamInsight` to schema

### Repositories & Services
- `InsightGenerator.swift` — **NEW FILE** for insight generation pipeline
- `EvidenceRepository.swift` — may need methods to query unprocessed evidence

### Views
- `AwarenessHost.swift` — replace runtime computation with `@Query`
- `PersonDetailHost.swift` — change insight type from `PersonInsight` to `SamInsight`
- `ContextDetailRouter.swift` — change insight type from `ContextInsight` to `SamInsight`
- `PersonDetailModel.swift` — update `insights` type
- `ContextDetailModel.swift` — update `insights` type
- `InsightCardView.swift` — extend for evidence drill-through (Phase 3)

### Fixtures & Testing
- `FixtureSeeder.swift` — replace embedded insight creation with `SamInsight` instances
- `BackupPayload.swift` — add `BackupInsight` DTO, update current/restore

### Deleted
- No files deleted (embedded structs stay in `SAMModelEnums.swift` for now as historical reference)
- `PersonInsight` and `ContextInsight` will remain as value types for backward compatibility during migration, then can be removed

---

## Success Criteria

- [ ] All insight cards in Person/Context detail views render correctly with `SamInsight`
- [ ] Insights persist across app launches
- [ ] Awareness screen shows insights derived from evidence signals
- [ ] Tapping an insight in Awareness navigates to the relevant person or context
- [ ] Evidence drill-through from insight cards works in all views
- [ ] Backup/restore preserves insights with correct relationships
- [ ] Dismissing an insight marks `dismissedAt` and hides it from views
- [ ] No duplicate insights for the same evidence/entity combination
- [ ] Performance is acceptable (insight generation doesn't block UI)

---

## Next Steps

1. **User confirmation:** Confirm unified model approach and navigation UX from Awareness
2. **Phase 1 implementation:** Start with `SamInsight` @Model and migrate Person/Context detail views
3. **Test Phase 1:** Verify fixtures, backup/restore, detail view rendering
4. **Phase 2 design:** Design insight generation pipeline and decide when it runs
5. **Phase 2 implementation:** Migrate Awareness to query `SamInsight`
6. **Test Phase 2:** Verify Awareness insights and navigation
7. **Phase 3 implementation:** Add evidence relationships
8. **Final testing:** End-to-end flow from evidence import → insight generation → Awareness → navigation → drill-through

---

## Notes for Future Enhancement

Once insights are first-class models:

- **Insight versioning:** Track when an insight message changes (e.g., confidence increases as more evidence accumulates)
- **Insight actions:** Attach suggested actions (schedule meeting, update consent, etc.) as relationships
- **Insight snoozing:** Add `snoozedUntil: Date?` for "Remind Me Later" functionality
- **Insight priority:** Add `priority: Int` separate from confidence for manual re-ordering
- **Insight templates:** Store reusable insight templates in DB for consistent messaging
- **Insight analytics:** Track which insights lead to action vs. dismissal for ML training
- **Cross-entity insights:** Insights that span multiple people/contexts (e.g., "Family structure change affects 3 households")

